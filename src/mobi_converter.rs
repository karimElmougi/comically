use anyhow::{Context, Result};
use std::fs;
use std::path::PathBuf;
use std::process::Command;

use crate::Comic;

/// Converts an EPUB file to MOBI using Amazon's KindleGen
pub fn create_mobi(comic: &Comic) -> Result<SpawnedKindleGen> {
    let epub_path = comic.epub_file();
    if !epub_path.exists() {
        anyhow::bail!("EPUB file does not exist: {}", epub_path.display());
    }

    if !is_kindlegen_available() {
        anyhow::bail!("KindleGen is not found in PATH. Please install KindleGen and make sure it's in your PATH.");
    }

    let child = Command::new("kindlegen")
        .arg("-dont_append_source")
        .arg("-c1")
        .arg("-locale")
        .arg("en")
        .arg(&epub_path)
        .stdout(std::process::Stdio::piped())
        .stderr(std::process::Stdio::piped())
        .spawn()
        .context("Failed to execute KindleGen")?;

    let spawned = SpawnedKindleGen {
        child,
        mobi_file: comic.epub_file().with_extension("mobi"),
        output_mobi: comic.output_mobi(),
    };

    Ok(spawned)
}

pub struct SpawnedKindleGen {
    child: std::process::Child,
    /// generated by KindleGen
    mobi_file: PathBuf,
    /// where the mobi file will be moved to
    output_mobi: PathBuf,
}

impl SpawnedKindleGen {
    pub fn try_wait(&mut self) -> Result<Option<std::process::ExitStatus>> {
        let output = self.child.try_wait()?;
        Ok(output)
    }

    pub fn wait(self) -> Result<()> {
        let output = self.child.wait_with_output()?;
        let output_str = String::from_utf8_lossy(&output.stdout);
        let has_error_output = output_str.lines().any(|line| line.starts_with("Error("));
        let kindlegen_status = output.status.code();

        match (self.mobi_file.exists(), self.mobi_file == self.output_mobi) {
            // File exists and needs to be moved
            (true, false) => {
                fs::rename(&self.mobi_file, &self.output_mobi).with_context(|| {
                    format!(
                        "Failed to move MOBI file from {} to {}",
                        self.mobi_file.display(),
                        self.output_mobi.display()
                    )
                })?;
                log::debug!("MOBI file moved to: {}", self.output_mobi.display());
            }
            // File doesn't exist
            (false, _) => {
                log::warn!(
                    "MOBI file not found at expected location: {}",
                    self.mobi_file.display()
                );

                // If KindleGen also failed, this is a real error
                if !output.status.success() || has_error_output {
                    anyhow::bail!(
                        "KindleGen failed with code {:?} and no MOBI file was created: {}",
                        kindlegen_status,
                        output_str
                    );
                }

                anyhow::bail!("KindleGen reported success but MOBI file was not created");
            }
            _ => {}
        }

        if !output.status.success() || has_error_output {
            log::warn!(
                "KindleGen reported issues (code {:?}) but MOBI file was created: {}",
                kindlegen_status,
                output_str
            );
        }

        log::debug!("MOBI creation successful: {}", self.output_mobi.display());
        Ok(())
    }
}

/// Checks if KindleGen is available in the PATH
fn is_kindlegen_available() -> bool {
    match Command::new("kindlegen").arg("-version").output() {
        Ok(_) => true,
        Err(_) => false,
    }
}
